//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g 2012-05-16 11:17:01

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


#pragma warning disable 3021
#pragma warning disable 0414


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
//[System.CLSCompliant(false)]
public partial class StateMachineTransitionParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARGTYPE_DELEGATE", "ARGTYPE_FLOAT", "ARGTYPE_INT", "FLOAT", "ID", "INT", "NEWLINE", "NOT", "PROG", "PROGEXPR", "PROGEXPR_RESTART", "VARARGS", "VARDECL", "VARDECLBLOCK", "VARNAME", "VARTYPE", "WS", "'&'", "'('", "')'", "','", "';'", "'{'", "'|'", "'}'"
	};
	public const int EOF=-1;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int ARGTYPE_DELEGATE=4;
	public const int ARGTYPE_FLOAT=5;
	public const int ARGTYPE_INT=6;
	public const int FLOAT=7;
	public const int ID=8;
	public const int INT=9;
	public const int NEWLINE=10;
	public const int NOT=11;
	public const int PROG=12;
	public const int PROGEXPR=13;
	public const int PROGEXPR_RESTART=14;
	public const int VARARGS=15;
	public const int VARDECL=16;
	public const int VARDECLBLOCK=17;
	public const int VARNAME=18;
	public const int VARTYPE=19;
	public const int WS=20;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public StateMachineTransitionParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public StateMachineTransitionParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}
	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return StateMachineTransitionParser.tokenNames; } }
	public override string GrammarFileName { get { return "/Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g"; } }


	public AstParserRuleReturnScope<CommonTree, IToken> process() {
		TreeAdaptor = new CommonTreeAdaptor();
		return prog();
	}


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_prog() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_prog() {}

	// $ANTLR start "prog"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:43:1: prog : ( declBlock )? expr -> ^( PROG ( declBlock )? expr ) ;
	[GrammarRule("prog")]
	private AstParserRuleReturnScope<CommonTree, IToken> prog()
	{
		EnterRule_prog();
		EnterRule("prog", 1);
		TraceIn("prog", 1);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    AstParserRuleReturnScope<CommonTree, IToken> declBlock1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> expr2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    RewriteRuleSubtreeStream stream_declBlock=new RewriteRuleSubtreeStream(adaptor,"rule declBlock");
	    RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "prog");
		DebugLocation(43, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:43:6: ( ( declBlock )? expr -> ^( PROG ( declBlock )? expr ) )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:43:9: ( declBlock )? expr
			{
			DebugLocation(43, 9);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:43:9: ( declBlock )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, decisionCanBacktrack[1]);
			try
			{
				alt1 = dfa1.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:43:9: declBlock
				{
				DebugLocation(43, 9);
				PushFollow(Follow._declBlock_in_prog119);
				declBlock1=declBlock();
				PopFollow();

				stream_declBlock.Add(declBlock1.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(43, 20);
			PushFollow(Follow._expr_in_prog122);
			expr2=expr();
			PopFollow();

			stream_expr.Add(expr2.Tree);


			{
			// AST REWRITE
			// elements: declBlock, expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 43:25: -> ^( PROG ( declBlock )? expr )
			{
				DebugLocation(43, 28);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:43:28: ^( PROG ( declBlock )? expr )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(43, 30);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROG, "PROG"), root_1);

				DebugLocation(43, 35);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:43:35: ( declBlock )?
				if (stream_declBlock.HasNext)
				{
					DebugLocation(43, 35);
					adaptor.AddChild(root_1, stream_declBlock.NextTree());

				}
				stream_declBlock.Reset();
				DebugLocation(43, 46);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prog", 1);
			LeaveRule("prog", 1);
			LeaveRule_prog();
	    }
	 	DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "prog"); }
		return retval;

	}
	// $ANTLR end "prog"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_declBlock() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_declBlock() {}

	// $ANTLR start "declBlock"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:1: declBlock : ( ignore )* '{' ( ignore )* ( decl )+ ( ignore )* '}' ( ignore )* -> ^( VARDECLBLOCK ( decl )+ ) ;
	[GrammarRule("declBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> declBlock()
	{
		EnterRule_declBlock();
		EnterRule("declBlock", 2);
		TraceIn("declBlock", 2);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken char_literal4 = default(IToken);
	    IToken char_literal8 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore3 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore5 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> decl6 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore7 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore9 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree char_literal4_tree = default(CommonTree);
	    CommonTree char_literal8_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_26=new RewriteRuleITokenStream(adaptor,"token 26");
	    RewriteRuleITokenStream stream_28=new RewriteRuleITokenStream(adaptor,"token 28");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_decl=new RewriteRuleSubtreeStream(adaptor,"rule decl");
		try { DebugEnterRule(GrammarFileName, "declBlock");
		DebugLocation(48, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:11: ( ( ignore )* '{' ( ignore )* ( decl )+ ( ignore )* '}' ( ignore )* -> ^( VARDECLBLOCK ( decl )+ ) )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:13: ( ignore )* '{' ( ignore )* ( decl )+ ( ignore )* '}' ( ignore )*
			{
			DebugLocation(48, 13);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:13: ( ignore )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, decisionCanBacktrack[2]);
				int LA2_0 = input.LA(1);

				if ((LA2_0==NEWLINE||LA2_0==WS))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:13: ignore
					{
					DebugLocation(48, 13);
					PushFollow(Follow._ignore_in_declBlock145);
					ignore3=ignore();
					PopFollow();

					stream_ignore.Add(ignore3.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(48, 21);
			char_literal4=(IToken)Match(input,26,Follow._26_in_declBlock148);  
			stream_26.Add(char_literal4);

			DebugLocation(48, 25);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:25: ( ignore )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, decisionCanBacktrack[3]);
				int LA3_0 = input.LA(1);

				if ((LA3_0==NEWLINE||LA3_0==WS))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:25: ignore
					{
					DebugLocation(48, 25);
					PushFollow(Follow._ignore_in_declBlock150);
					ignore5=ignore();
					PopFollow();

					stream_ignore.Add(ignore5.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(48, 33);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:33: ( decl )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, decisionCanBacktrack[4]);
				try
				{
					alt4 = dfa4.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:33: decl
					{
					DebugLocation(48, 33);
					PushFollow(Follow._decl_in_declBlock153);
					decl6=decl();
					PopFollow();

					stream_decl.Add(decl6.Tree);

					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(48, 39);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:39: ( ignore )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, decisionCanBacktrack[5]);
				int LA5_0 = input.LA(1);

				if ((LA5_0==NEWLINE||LA5_0==WS))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:39: ignore
					{
					DebugLocation(48, 39);
					PushFollow(Follow._ignore_in_declBlock156);
					ignore7=ignore();
					PopFollow();

					stream_ignore.Add(ignore7.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(48, 47);
			char_literal8=(IToken)Match(input,28,Follow._28_in_declBlock159);  
			stream_28.Add(char_literal8);

			DebugLocation(48, 51);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:51: ( ignore )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, decisionCanBacktrack[6]);
				int LA6_0 = input.LA(1);

				if ((LA6_0==NEWLINE||LA6_0==WS))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:51: ignore
					{
					DebugLocation(48, 51);
					PushFollow(Follow._ignore_in_declBlock161);
					ignore9=ignore();
					PopFollow();

					stream_ignore.Add(ignore9.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: decl
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 48:59: -> ^( VARDECLBLOCK ( decl )+ )
			{
				DebugLocation(48, 62);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:48:62: ^( VARDECLBLOCK ( decl )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(48, 64);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARDECLBLOCK, "VARDECLBLOCK"), root_1);

				DebugLocation(48, 77);
				if (!(stream_decl.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_decl.HasNext )
				{
					DebugLocation(48, 77);
					adaptor.AddChild(root_1, stream_decl.NextTree());

				}
				stream_decl.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declBlock", 2);
			LeaveRule("declBlock", 2);
			LeaveRule_declBlock();
	    }
	 	DebugLocation(49, 1);
		} finally { DebugExitRule(GrammarFileName, "declBlock"); }
		return retval;

	}
	// $ANTLR end "declBlock"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_decl() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_decl() {}

	// $ANTLR start "decl"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:1: decl : ( ignore )* type ( ignore )* name ( ignore )* '(' ( ignore )* ( args )? ')' ( ignore )* ';' -> ^( VARDECL name type ( args )? ) ;
	[GrammarRule("decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> decl()
	{
		EnterRule_decl();
		EnterRule("decl", 3);
		TraceIn("decl", 3);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken char_literal15 = default(IToken);
	    IToken char_literal18 = default(IToken);
	    IToken char_literal20 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore10 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> type11 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore12 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> name13 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore14 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore16 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> args17 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore19 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree char_literal15_tree = default(CommonTree);
	    CommonTree char_literal18_tree = default(CommonTree);
	    CommonTree char_literal20_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_22=new RewriteRuleITokenStream(adaptor,"token 22");
	    RewriteRuleITokenStream stream_23=new RewriteRuleITokenStream(adaptor,"token 23");
	    RewriteRuleITokenStream stream_25=new RewriteRuleITokenStream(adaptor,"token 25");
	    RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args");
	    RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
	    RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
		try { DebugEnterRule(GrammarFileName, "decl");
		DebugLocation(51, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:6: ( ( ignore )* type ( ignore )* name ( ignore )* '(' ( ignore )* ( args )? ')' ( ignore )* ';' -> ^( VARDECL name type ( args )? ) )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:8: ( ignore )* type ( ignore )* name ( ignore )* '(' ( ignore )* ( args )? ')' ( ignore )* ';'
			{
			DebugLocation(51, 8);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:8: ( ignore )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, decisionCanBacktrack[7]);
				int LA7_0 = input.LA(1);

				if ((LA7_0==NEWLINE||LA7_0==WS))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:8: ignore
					{
					DebugLocation(51, 8);
					PushFollow(Follow._ignore_in_decl181);
					ignore10=ignore();
					PopFollow();

					stream_ignore.Add(ignore10.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(51, 16);
			PushFollow(Follow._type_in_decl184);
			type11=type();
			PopFollow();

			stream_type.Add(type11.Tree);
			DebugLocation(51, 21);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:21: ( ignore )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, decisionCanBacktrack[8]);
				int LA8_0 = input.LA(1);

				if ((LA8_0==NEWLINE||LA8_0==WS))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:21: ignore
					{
					DebugLocation(51, 21);
					PushFollow(Follow._ignore_in_decl186);
					ignore12=ignore();
					PopFollow();

					stream_ignore.Add(ignore12.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(51, 29);
			PushFollow(Follow._name_in_decl189);
			name13=name();
			PopFollow();

			stream_name.Add(name13.Tree);
			DebugLocation(51, 34);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:34: ( ignore )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, decisionCanBacktrack[9]);
				int LA9_0 = input.LA(1);

				if ((LA9_0==NEWLINE||LA9_0==WS))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:34: ignore
					{
					DebugLocation(51, 34);
					PushFollow(Follow._ignore_in_decl191);
					ignore14=ignore();
					PopFollow();

					stream_ignore.Add(ignore14.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(51, 42);
			char_literal15=(IToken)Match(input,22,Follow._22_in_decl194);  
			stream_22.Add(char_literal15);

			DebugLocation(51, 46);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:46: ( ignore )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, decisionCanBacktrack[10]);
				int LA10_0 = input.LA(1);

				if ((LA10_0==NEWLINE||LA10_0==WS))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:46: ignore
					{
					DebugLocation(51, 46);
					PushFollow(Follow._ignore_in_decl196);
					ignore16=ignore();
					PopFollow();

					stream_ignore.Add(ignore16.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(51, 54);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:54: ( args )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, decisionCanBacktrack[11]);
			int LA11_0 = input.LA(1);

			if (((LA11_0>=FLOAT && LA11_0<=INT)))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:54: args
				{
				DebugLocation(51, 54);
				PushFollow(Follow._args_in_decl199);
				args17=args();
				PopFollow();

				stream_args.Add(args17.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(51, 60);
			char_literal18=(IToken)Match(input,23,Follow._23_in_decl202);  
			stream_23.Add(char_literal18);

			DebugLocation(51, 64);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:64: ( ignore )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, decisionCanBacktrack[12]);
				int LA12_0 = input.LA(1);

				if ((LA12_0==NEWLINE||LA12_0==WS))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:64: ignore
					{
					DebugLocation(51, 64);
					PushFollow(Follow._ignore_in_decl204);
					ignore19=ignore();
					PopFollow();

					stream_ignore.Add(ignore19.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(51, 72);
			char_literal20=(IToken)Match(input,25,Follow._25_in_decl207);  
			stream_25.Add(char_literal20);



			{
			// AST REWRITE
			// elements: type, name, args
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 51:76: -> ^( VARDECL name type ( args )? )
			{
				DebugLocation(51, 79);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:79: ^( VARDECL name type ( args )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(51, 81);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARDECL, "VARDECL"), root_1);

				DebugLocation(51, 89);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(51, 94);
				adaptor.AddChild(root_1, stream_type.NextTree());
				DebugLocation(51, 99);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:51:99: ( args )?
				if (stream_args.HasNext)
				{
					DebugLocation(51, 99);
					adaptor.AddChild(root_1, stream_args.NextTree());

				}
				stream_args.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decl", 3);
			LeaveRule("decl", 3);
			LeaveRule_decl();
	    }
	 	DebugLocation(52, 1);
		} finally { DebugExitRule(GrammarFileName, "decl"); }
		return retval;

	}
	// $ANTLR end "decl"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_type() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_type() {}

	// $ANTLR start "type"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:54:1: type : ID -> ^( VARTYPE ID ) ;
	[GrammarRule("type")]
	private AstParserRuleReturnScope<CommonTree, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 4);
		TraceIn("type", 4);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken ID21 = default(IToken);

	    CommonTree ID21_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(54, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:54:6: ( ID -> ^( VARTYPE ID ) )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:54:8: ID
			{
			DebugLocation(54, 8);
			ID21=(IToken)Match(input,ID,Follow._ID_in_type231);  
			stream_ID.Add(ID21);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 54:11: -> ^( VARTYPE ID )
			{
				DebugLocation(54, 14);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:54:14: ^( VARTYPE ID )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(54, 16);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARTYPE, "VARTYPE"), root_1);

				DebugLocation(54, 24);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 4);
			LeaveRule("type", 4);
			LeaveRule_type();
	    }
	 	DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_name() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_name() {}

	// $ANTLR start "name"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:57:1: name : ID -> ^( VARNAME ID ) ;
	[GrammarRule("name")]
	private AstParserRuleReturnScope<CommonTree, IToken> name()
	{
		EnterRule_name();
		EnterRule("name", 5);
		TraceIn("name", 5);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken ID22 = default(IToken);

	    CommonTree ID22_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "name");
		DebugLocation(57, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:58:2: ( ID -> ^( VARNAME ID ) )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:58:4: ID
			{
			DebugLocation(58, 4);
			ID22=(IToken)Match(input,ID,Follow._ID_in_name252);  
			stream_ID.Add(ID22);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 58:7: -> ^( VARNAME ID )
			{
				DebugLocation(58, 10);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:58:10: ^( VARNAME ID )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(58, 12);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARNAME, "VARNAME"), root_1);

				DebugLocation(58, 20);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name", 5);
			LeaveRule("name", 5);
			LeaveRule_name();
	    }
	 	DebugLocation(59, 1);
		} finally { DebugExitRule(GrammarFileName, "name"); }
		return retval;

	}
	// $ANTLR end "name"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_args() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_args() {}

	// $ANTLR start "args"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:1: args : arg ( ignore )* ( ',' ( ignore )* arg ( ignore )* )* -> ^( VARARGS ( arg )+ ) ;
	[GrammarRule("args")]
	private AstParserRuleReturnScope<CommonTree, IToken> args()
	{
		EnterRule_args();
		EnterRule("args", 6);
		TraceIn("args", 6);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken char_literal25 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> arg23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore24 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore26 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> arg27 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore28 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree char_literal25_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_24=new RewriteRuleITokenStream(adaptor,"token 24");
	    RewriteRuleSubtreeStream stream_arg=new RewriteRuleSubtreeStream(adaptor,"rule arg");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
		try { DebugEnterRule(GrammarFileName, "args");
		DebugLocation(61, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:6: ( arg ( ignore )* ( ',' ( ignore )* arg ( ignore )* )* -> ^( VARARGS ( arg )+ ) )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:8: arg ( ignore )* ( ',' ( ignore )* arg ( ignore )* )*
			{
			DebugLocation(61, 8);
			PushFollow(Follow._arg_in_args271);
			arg23=arg();
			PopFollow();

			stream_arg.Add(arg23.Tree);
			DebugLocation(61, 12);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:12: ( ignore )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, decisionCanBacktrack[13]);
				int LA13_0 = input.LA(1);

				if ((LA13_0==NEWLINE||LA13_0==WS))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:12: ignore
					{
					DebugLocation(61, 12);
					PushFollow(Follow._ignore_in_args273);
					ignore24=ignore();
					PopFollow();

					stream_ignore.Add(ignore24.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(61, 20);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:20: ( ',' ( ignore )* arg ( ignore )* )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, decisionCanBacktrack[16]);
				int LA16_0 = input.LA(1);

				if ((LA16_0==24))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:22: ',' ( ignore )* arg ( ignore )*
					{
					DebugLocation(61, 22);
					char_literal25=(IToken)Match(input,24,Follow._24_in_args278);  
					stream_24.Add(char_literal25);

					DebugLocation(61, 26);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:26: ( ignore )*
					try { DebugEnterSubRule(14);
					while (true)
					{
						int alt14=2;
						try { DebugEnterDecision(14, decisionCanBacktrack[14]);
						int LA14_0 = input.LA(1);

						if ((LA14_0==NEWLINE||LA14_0==WS))
						{
							alt14 = 1;
						}


						} finally { DebugExitDecision(14); }
						switch ( alt14 )
						{
						case 1:
							DebugEnterAlt(1);
							// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:26: ignore
							{
							DebugLocation(61, 26);
							PushFollow(Follow._ignore_in_args280);
							ignore26=ignore();
							PopFollow();

							stream_ignore.Add(ignore26.Tree);

							}
							break;

						default:
							goto loop14;
						}
					}

					loop14:
						;

					} finally { DebugExitSubRule(14); }

					DebugLocation(61, 34);
					PushFollow(Follow._arg_in_args283);
					arg27=arg();
					PopFollow();

					stream_arg.Add(arg27.Tree);
					DebugLocation(61, 38);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:38: ( ignore )*
					try { DebugEnterSubRule(15);
					while (true)
					{
						int alt15=2;
						try { DebugEnterDecision(15, decisionCanBacktrack[15]);
						int LA15_0 = input.LA(1);

						if ((LA15_0==NEWLINE||LA15_0==WS))
						{
							alt15 = 1;
						}


						} finally { DebugExitDecision(15); }
						switch ( alt15 )
						{
						case 1:
							DebugEnterAlt(1);
							// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:38: ignore
							{
							DebugLocation(61, 38);
							PushFollow(Follow._ignore_in_args285);
							ignore28=ignore();
							PopFollow();

							stream_ignore.Add(ignore28.Tree);

							}
							break;

						default:
							goto loop15;
						}
					}

					loop15:
						;

					} finally { DebugExitSubRule(15); }


					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }



			{
			// AST REWRITE
			// elements: arg
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 61:49: -> ^( VARARGS ( arg )+ )
			{
				DebugLocation(61, 52);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:61:52: ^( VARARGS ( arg )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(61, 54);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARARGS, "VARARGS"), root_1);

				DebugLocation(61, 62);
				if (!(stream_arg.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_arg.HasNext )
				{
					DebugLocation(61, 62);
					adaptor.AddChild(root_1, stream_arg.NextTree());

				}
				stream_arg.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("args", 6);
			LeaveRule("args", 6);
			LeaveRule_args();
	    }
	 	DebugLocation(62, 1);
		} finally { DebugExitRule(GrammarFileName, "args"); }
		return retval;

	}
	// $ANTLR end "args"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_arg() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_arg() {}

	// $ANTLR start "arg"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:64:1: arg : ( ID -> ^( ARGTYPE_DELEGATE ID ) | INT -> ^( ARGTYPE_INT INT ) | FLOAT -> ^( ARGTYPE_FLOAT FLOAT ) );
	[GrammarRule("arg")]
	private AstParserRuleReturnScope<CommonTree, IToken> arg()
	{
		EnterRule_arg();
		EnterRule("arg", 7);
		TraceIn("arg", 7);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken ID29 = default(IToken);
	    IToken INT30 = default(IToken);
	    IToken FLOAT31 = default(IToken);

	    CommonTree ID29_tree = default(CommonTree);
	    CommonTree INT30_tree = default(CommonTree);
	    CommonTree FLOAT31_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_FLOAT=new RewriteRuleITokenStream(adaptor,"token FLOAT");
	    RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
	    RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "arg");
		DebugLocation(64, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:64:5: ( ID -> ^( ARGTYPE_DELEGATE ID ) | INT -> ^( ARGTYPE_INT INT ) | FLOAT -> ^( ARGTYPE_FLOAT FLOAT ) )
			int alt17=3;
			try { DebugEnterDecision(17, decisionCanBacktrack[17]);
			switch (input.LA(1))
			{
			case ID:
				{
				alt17 = 1;
				}
				break;
			case INT:
				{
				alt17 = 2;
				}
				break;
			case FLOAT:
				{
				alt17 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:64:7: ID
				{
				DebugLocation(64, 7);
				ID29=(IToken)Match(input,ID,Follow._ID_in_arg308);  
				stream_ID.Add(ID29);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 64:10: -> ^( ARGTYPE_DELEGATE ID )
				{
					DebugLocation(64, 13);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:64:13: ^( ARGTYPE_DELEGATE ID )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(64, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARGTYPE_DELEGATE, "ARGTYPE_DELEGATE"), root_1);

					DebugLocation(64, 32);
					adaptor.AddChild(root_1, stream_ID.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:65:4: INT
				{
				DebugLocation(65, 4);
				INT30=(IToken)Match(input,INT,Follow._INT_in_arg321);  
				stream_INT.Add(INT30);



				{
				// AST REWRITE
				// elements: INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 65:8: -> ^( ARGTYPE_INT INT )
				{
					DebugLocation(65, 11);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:65:11: ^( ARGTYPE_INT INT )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(65, 13);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARGTYPE_INT, "ARGTYPE_INT"), root_1);

					DebugLocation(65, 25);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:66:4: FLOAT
				{
				DebugLocation(66, 4);
				FLOAT31=(IToken)Match(input,FLOAT,Follow._FLOAT_in_arg334);  
				stream_FLOAT.Add(FLOAT31);



				{
				// AST REWRITE
				// elements: FLOAT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 66:10: -> ^( ARGTYPE_FLOAT FLOAT )
				{
					DebugLocation(66, 13);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:66:13: ^( ARGTYPE_FLOAT FLOAT )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(66, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARGTYPE_FLOAT, "ARGTYPE_FLOAT"), root_1);

					DebugLocation(66, 29);
					adaptor.AddChild(root_1, stream_FLOAT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arg", 7);
			LeaveRule("arg", 7);
			LeaveRule_arg();
	    }
	 	DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "arg"); }
		return retval;

	}
	// $ANTLR end "arg"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expr() {}

	// $ANTLR start "expr"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:1: expr : ( ignore )* ( orExpr )+ ( ignore )* -> ^( PROGEXPR ( orExpr )+ PROGEXPR_RESTART ) ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 8);
		TraceIn("expr", 8);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    AstParserRuleReturnScope<CommonTree, IToken> ignore32 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> orExpr33 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore34 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_orExpr=new RewriteRuleSubtreeStream(adaptor,"rule orExpr");
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(71, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:6: ( ( ignore )* ( orExpr )+ ( ignore )* -> ^( PROGEXPR ( orExpr )+ PROGEXPR_RESTART ) )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:8: ( ignore )* ( orExpr )+ ( ignore )*
			{
			DebugLocation(71, 8);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:8: ( ignore )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, decisionCanBacktrack[18]);
				int LA18_0 = input.LA(1);

				if ((LA18_0==NEWLINE||LA18_0==WS))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:8: ignore
					{
					DebugLocation(71, 8);
					PushFollow(Follow._ignore_in_expr354);
					ignore32=ignore();
					PopFollow();

					stream_ignore.Add(ignore32.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(71, 16);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:16: ( orExpr )+
			int cnt19=0;
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, decisionCanBacktrack[19]);
				int LA19_0 = input.LA(1);

				if ((LA19_0==ID||LA19_0==NOT))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:16: orExpr
					{
					DebugLocation(71, 16);
					PushFollow(Follow._orExpr_in_expr357);
					orExpr33=orExpr();
					PopFollow();

					stream_orExpr.Add(orExpr33.Tree);

					}
					break;

				default:
					if (cnt19 >= 1)
						goto loop19;

					EarlyExitException eee19 = new EarlyExitException( 19, input );
					DebugRecognitionException(eee19);
					throw eee19;
				}
				cnt19++;
			}
			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(71, 24);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:24: ( ignore )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, decisionCanBacktrack[20]);
				int LA20_0 = input.LA(1);

				if ((LA20_0==NEWLINE||LA20_0==WS))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:24: ignore
					{
					DebugLocation(71, 24);
					PushFollow(Follow._ignore_in_expr360);
					ignore34=ignore();
					PopFollow();

					stream_ignore.Add(ignore34.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }



			{
			// AST REWRITE
			// elements: orExpr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 71:32: -> ^( PROGEXPR ( orExpr )+ PROGEXPR_RESTART )
			{
				DebugLocation(71, 35);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:71:35: ^( PROGEXPR ( orExpr )+ PROGEXPR_RESTART )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(71, 38);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROGEXPR, "PROGEXPR"), root_1);

				DebugLocation(71, 47);
				if (!(stream_orExpr.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_orExpr.HasNext )
				{
					DebugLocation(71, 47);
					adaptor.AddChild(root_1, stream_orExpr.NextTree());

				}
				stream_orExpr.Reset();
				DebugLocation(71, 55);
				adaptor.AddChild(root_1, (CommonTree)adaptor.Create(PROGEXPR_RESTART, "PROGEXPR_RESTART"));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 8);
			LeaveRule("expr", 8);
			LeaveRule_expr();
	    }
	 	DebugLocation(72, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_orExpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_orExpr() {}

	// $ANTLR start "orExpr"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:74:1: orExpr : ( andExpr -> andExpr ) ( ( ignore )* '|' ( ignore )* a= andExpr -> ^( '|' $orExpr $a) )* ;
	[GrammarRule("orExpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> orExpr()
	{
		EnterRule_orExpr();
		EnterRule("orExpr", 9);
		TraceIn("orExpr", 9);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken char_literal37 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> andExpr35 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore38 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree char_literal37_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_27=new RewriteRuleITokenStream(adaptor,"token 27");
	    RewriteRuleSubtreeStream stream_andExpr=new RewriteRuleSubtreeStream(adaptor,"rule andExpr");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
		try { DebugEnterRule(GrammarFileName, "orExpr");
		DebugLocation(74, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:2: ( ( andExpr -> andExpr ) ( ( ignore )* '|' ( ignore )* a= andExpr -> ^( '|' $orExpr $a) )* )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:4: ( andExpr -> andExpr ) ( ( ignore )* '|' ( ignore )* a= andExpr -> ^( '|' $orExpr $a) )*
			{
			DebugLocation(75, 4);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:4: ( andExpr -> andExpr )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:5: andExpr
			{
			DebugLocation(75, 5);
			PushFollow(Follow._andExpr_in_orExpr387);
			andExpr35=andExpr();
			PopFollow();

			stream_andExpr.Add(andExpr35.Tree);


			{
			// AST REWRITE
			// elements: andExpr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 75:13: -> andExpr
			{
				DebugLocation(75, 16);
				adaptor.AddChild(root_0, stream_andExpr.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(75, 25);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:25: ( ( ignore )* '|' ( ignore )* a= andExpr -> ^( '|' $orExpr $a) )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, decisionCanBacktrack[23]);
				try
				{
					alt23 = dfa23.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:26: ( ignore )* '|' ( ignore )* a= andExpr
					{
					DebugLocation(75, 26);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:26: ( ignore )*
					try { DebugEnterSubRule(21);
					while (true)
					{
						int alt21=2;
						try { DebugEnterDecision(21, decisionCanBacktrack[21]);
						int LA21_0 = input.LA(1);

						if ((LA21_0==NEWLINE||LA21_0==WS))
						{
							alt21 = 1;
						}


						} finally { DebugExitDecision(21); }
						switch ( alt21 )
						{
						case 1:
							DebugEnterAlt(1);
							// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:26: ignore
							{
							DebugLocation(75, 26);
							PushFollow(Follow._ignore_in_orExpr395);
							ignore36=ignore();
							PopFollow();

							stream_ignore.Add(ignore36.Tree);

							}
							break;

						default:
							goto loop21;
						}
					}

					loop21:
						;

					} finally { DebugExitSubRule(21); }

					DebugLocation(75, 34);
					char_literal37=(IToken)Match(input,27,Follow._27_in_orExpr398);  
					stream_27.Add(char_literal37);

					DebugLocation(75, 38);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:38: ( ignore )*
					try { DebugEnterSubRule(22);
					while (true)
					{
						int alt22=2;
						try { DebugEnterDecision(22, decisionCanBacktrack[22]);
						int LA22_0 = input.LA(1);

						if ((LA22_0==NEWLINE||LA22_0==WS))
						{
							alt22 = 1;
						}


						} finally { DebugExitDecision(22); }
						switch ( alt22 )
						{
						case 1:
							DebugEnterAlt(1);
							// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:38: ignore
							{
							DebugLocation(75, 38);
							PushFollow(Follow._ignore_in_orExpr400);
							ignore38=ignore();
							PopFollow();

							stream_ignore.Add(ignore38.Tree);

							}
							break;

						default:
							goto loop22;
						}
					}

					loop22:
						;

					} finally { DebugExitSubRule(22); }

					DebugLocation(75, 47);
					PushFollow(Follow._andExpr_in_orExpr405);
					a=andExpr();
					PopFollow();

					stream_andExpr.Add(a.Tree);


					{
					// AST REWRITE
					// elements: a, 27, orExpr
					// token labels: 
					// rule labels: retval, a
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 75:56: -> ^( '|' $orExpr $a)
					{
						DebugLocation(75, 59);
						// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:75:59: ^( '|' $orExpr $a)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(75, 61);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_27.NextNode(), root_1);

						DebugLocation(75, 66);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(75, 74);
						adaptor.AddChild(root_1, stream_a.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orExpr", 9);
			LeaveRule("orExpr", 9);
			LeaveRule_orExpr();
	    }
	 	DebugLocation(76, 1);
		} finally { DebugExitRule(GrammarFileName, "orExpr"); }
		return retval;

	}
	// $ANTLR end "orExpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_andExpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_andExpr() {}

	// $ANTLR start "andExpr"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:78:1: andExpr : ( term -> term ) ( ( ignore )* '&' ( ignore )* a= term -> ^( '&' $andExpr $a) )* ;
	[GrammarRule("andExpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> andExpr()
	{
		EnterRule_andExpr();
		EnterRule("andExpr", 10);
		TraceIn("andExpr", 10);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken char_literal41 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> term39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore42 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree char_literal41_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_21=new RewriteRuleITokenStream(adaptor,"token 21");
	    RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
		try { DebugEnterRule(GrammarFileName, "andExpr");
		DebugLocation(78, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:2: ( ( term -> term ) ( ( ignore )* '&' ( ignore )* a= term -> ^( '&' $andExpr $a) )* )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:4: ( term -> term ) ( ( ignore )* '&' ( ignore )* a= term -> ^( '&' $andExpr $a) )*
			{
			DebugLocation(79, 4);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:4: ( term -> term )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:5: term
			{
			DebugLocation(79, 5);
			PushFollow(Follow._term_in_andExpr432);
			term39=term();
			PopFollow();

			stream_term.Add(term39.Tree);


			{
			// AST REWRITE
			// elements: term
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 79:10: -> term
			{
				DebugLocation(79, 13);
				adaptor.AddChild(root_0, stream_term.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(79, 19);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:19: ( ( ignore )* '&' ( ignore )* a= term -> ^( '&' $andExpr $a) )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, decisionCanBacktrack[26]);
				try
				{
					alt26 = dfa26.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:20: ( ignore )* '&' ( ignore )* a= term
					{
					DebugLocation(79, 20);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:20: ( ignore )*
					try { DebugEnterSubRule(24);
					while (true)
					{
						int alt24=2;
						try { DebugEnterDecision(24, decisionCanBacktrack[24]);
						int LA24_0 = input.LA(1);

						if ((LA24_0==NEWLINE||LA24_0==WS))
						{
							alt24 = 1;
						}


						} finally { DebugExitDecision(24); }
						switch ( alt24 )
						{
						case 1:
							DebugEnterAlt(1);
							// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:20: ignore
							{
							DebugLocation(79, 20);
							PushFollow(Follow._ignore_in_andExpr440);
							ignore40=ignore();
							PopFollow();

							stream_ignore.Add(ignore40.Tree);

							}
							break;

						default:
							goto loop24;
						}
					}

					loop24:
						;

					} finally { DebugExitSubRule(24); }

					DebugLocation(79, 28);
					char_literal41=(IToken)Match(input,21,Follow._21_in_andExpr443);  
					stream_21.Add(char_literal41);

					DebugLocation(79, 32);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:32: ( ignore )*
					try { DebugEnterSubRule(25);
					while (true)
					{
						int alt25=2;
						try { DebugEnterDecision(25, decisionCanBacktrack[25]);
						int LA25_0 = input.LA(1);

						if ((LA25_0==NEWLINE||LA25_0==WS))
						{
							alt25 = 1;
						}


						} finally { DebugExitDecision(25); }
						switch ( alt25 )
						{
						case 1:
							DebugEnterAlt(1);
							// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:32: ignore
							{
							DebugLocation(79, 32);
							PushFollow(Follow._ignore_in_andExpr445);
							ignore42=ignore();
							PopFollow();

							stream_ignore.Add(ignore42.Tree);

							}
							break;

						default:
							goto loop25;
						}
					}

					loop25:
						;

					} finally { DebugExitSubRule(25); }

					DebugLocation(79, 41);
					PushFollow(Follow._term_in_andExpr450);
					a=term();
					PopFollow();

					stream_term.Add(a.Tree);


					{
					// AST REWRITE
					// elements: andExpr, 21, a
					// token labels: 
					// rule labels: retval, a
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 79:47: -> ^( '&' $andExpr $a)
					{
						DebugLocation(79, 50);
						// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:79:50: ^( '&' $andExpr $a)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(79, 52);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_21.NextNode(), root_1);

						DebugLocation(79, 57);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(79, 66);
						adaptor.AddChild(root_1, stream_a.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("andExpr", 10);
			LeaveRule("andExpr", 10);
			LeaveRule_andExpr();
	    }
	 	DebugLocation(80, 1);
		} finally { DebugExitRule(GrammarFileName, "andExpr"); }
		return retval;

	}
	// $ANTLR end "andExpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_term() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_term() {}

	// $ANTLR start "term"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:82:1: term : ( NOT ID -> ^( NOT ID ) | ID );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 11);
		TraceIn("term", 11);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken NOT43 = default(IToken);
	    IToken ID44 = default(IToken);
	    IToken ID45 = default(IToken);

	    CommonTree NOT43_tree = default(CommonTree);
	    CommonTree ID44_tree = default(CommonTree);
	    CommonTree ID45_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
	    RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(82, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:82:7: ( NOT ID -> ^( NOT ID ) | ID )
			int alt27=2;
			try { DebugEnterDecision(27, decisionCanBacktrack[27]);
			int LA27_0 = input.LA(1);

			if ((LA27_0==NOT))
			{
				alt27 = 1;
			}
			else if ((LA27_0==ID))
			{
				alt27 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:82:9: NOT ID
				{
				DebugLocation(82, 9);
				NOT43=(IToken)Match(input,NOT,Follow._NOT_in_term476);  
				stream_NOT.Add(NOT43);

				DebugLocation(82, 13);
				ID44=(IToken)Match(input,ID,Follow._ID_in_term478);  
				stream_ID.Add(ID44);



				{
				// AST REWRITE
				// elements: ID, NOT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 82:16: -> ^( NOT ID )
				{
					DebugLocation(82, 19);
					// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:82:19: ^( NOT ID )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(82, 22);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_NOT.NextNode(), root_1);

					DebugLocation(82, 26);
					adaptor.AddChild(root_1, stream_ID.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:83:4: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(83, 4);
				ID45=(IToken)Match(input,ID,Follow._ID_in_term493); 
				ID45_tree = (CommonTree)adaptor.Create(ID45);
				adaptor.AddChild(root_0, ID45_tree);


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 11);
			LeaveRule("term", 11);
			LeaveRule_term();
	    }
	 	DebugLocation(84, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_atom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_atom() {}

	// $ANTLR start "atom"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:86:1: atom : ( ID | '(' ( ignore )* orExpr ( ignore )* ')' -> orExpr );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<CommonTree, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 12);
		TraceIn("atom", 12);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken ID46 = default(IToken);
	    IToken char_literal47 = default(IToken);
	    IToken char_literal51 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore48 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> orExpr49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore50 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree ID46_tree = default(CommonTree);
	    CommonTree char_literal47_tree = default(CommonTree);
	    CommonTree char_literal51_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_22=new RewriteRuleITokenStream(adaptor,"token 22");
	    RewriteRuleITokenStream stream_23=new RewriteRuleITokenStream(adaptor,"token 23");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_orExpr=new RewriteRuleSubtreeStream(adaptor,"rule orExpr");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(86, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:87:2: ( ID | '(' ( ignore )* orExpr ( ignore )* ')' -> orExpr )
			int alt30=2;
			try { DebugEnterDecision(30, decisionCanBacktrack[30]);
			int LA30_0 = input.LA(1);

			if ((LA30_0==ID))
			{
				alt30 = 1;
			}
			else if ((LA30_0==22))
			{
				alt30 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:87:4: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(87, 4);
				ID46=(IToken)Match(input,ID,Follow._ID_in_atom505); 
				ID46_tree = (CommonTree)adaptor.Create(ID46);
				adaptor.AddChild(root_0, ID46_tree);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:88:5: '(' ( ignore )* orExpr ( ignore )* ')'
				{
				DebugLocation(88, 5);
				char_literal47=(IToken)Match(input,22,Follow._22_in_atom511);  
				stream_22.Add(char_literal47);

				DebugLocation(88, 9);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:88:9: ( ignore )*
				try { DebugEnterSubRule(28);
				while (true)
				{
					int alt28=2;
					try { DebugEnterDecision(28, decisionCanBacktrack[28]);
					int LA28_0 = input.LA(1);

					if ((LA28_0==NEWLINE||LA28_0==WS))
					{
						alt28 = 1;
					}


					} finally { DebugExitDecision(28); }
					switch ( alt28 )
					{
					case 1:
						DebugEnterAlt(1);
						// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:88:9: ignore
						{
						DebugLocation(88, 9);
						PushFollow(Follow._ignore_in_atom513);
						ignore48=ignore();
						PopFollow();

						stream_ignore.Add(ignore48.Tree);

						}
						break;

					default:
						goto loop28;
					}
				}

				loop28:
					;

				} finally { DebugExitSubRule(28); }

				DebugLocation(88, 17);
				PushFollow(Follow._orExpr_in_atom516);
				orExpr49=orExpr();
				PopFollow();

				stream_orExpr.Add(orExpr49.Tree);
				DebugLocation(88, 24);
				// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:88:24: ( ignore )*
				try { DebugEnterSubRule(29);
				while (true)
				{
					int alt29=2;
					try { DebugEnterDecision(29, decisionCanBacktrack[29]);
					int LA29_0 = input.LA(1);

					if ((LA29_0==NEWLINE||LA29_0==WS))
					{
						alt29 = 1;
					}


					} finally { DebugExitDecision(29); }
					switch ( alt29 )
					{
					case 1:
						DebugEnterAlt(1);
						// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:88:24: ignore
						{
						DebugLocation(88, 24);
						PushFollow(Follow._ignore_in_atom518);
						ignore50=ignore();
						PopFollow();

						stream_ignore.Add(ignore50.Tree);

						}
						break;

					default:
						goto loop29;
					}
				}

				loop29:
					;

				} finally { DebugExitSubRule(29); }

				DebugLocation(88, 32);
				char_literal51=(IToken)Match(input,23,Follow._23_in_atom521);  
				stream_23.Add(char_literal51);



				{
				// AST REWRITE
				// elements: orExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 88:36: -> orExpr
				{
					DebugLocation(88, 39);
					adaptor.AddChild(root_0, stream_orExpr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 12);
			LeaveRule("atom", 12);
			LeaveRule_atom();
	    }
	 	DebugLocation(89, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_ignore() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_ignore() {}

	// $ANTLR start "ignore"
	// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:91:1: ignore : ( WS | NEWLINE ) ;
	[GrammarRule("ignore")]
	private AstParserRuleReturnScope<CommonTree, IToken> ignore()
	{
		EnterRule_ignore();
		EnterRule("ignore", 13);
		TraceIn("ignore", 13);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken set52 = default(IToken);

	    CommonTree set52_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "ignore");
		DebugLocation(91, 1);
		try
		{
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:91:9: ( ( WS | NEWLINE ) )
			DebugEnterAlt(1);
			// /Users/Abahr/TrailsForward/Assets/_Scripts/Library/StateMachine/StateMachineTransition.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(91, 9);

			set52=(IToken)input.LT(1);
			if (input.LA(1)==NEWLINE||input.LA(1)==WS)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set52));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ignore", 13);
			LeaveRule("ignore", 13);
			LeaveRule_ignore();
	    }
	 	DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "ignore"); }
		return retval;

	}
	// $ANTLR end "ignore"
	#endregion Rules


	#region DFA
	private DFA1 dfa1;
	private DFA4 dfa4;
	private DFA23 dfa23;
	private DFA26 dfa26;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa1 = new DFA1( this );
		dfa4 = new DFA4( this );
		dfa23 = new DFA23( this );
		dfa26 = new DFA26( this );
	}

	private class DFA1 : DFA
	{
		private const string DFA1_eotS =
			"\x4\xFFFF";
		private const string DFA1_eofS =
			"\x4\xFFFF";
		private const string DFA1_minS =
			"\x2\x8\x2\xFFFF";
		private const string DFA1_maxS =
			"\x2\x1A\x2\xFFFF";
		private const string DFA1_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA1_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA1_transitionS =
			{
				"\x1\x3\x1\xFFFF\x1\x1\x1\x3\x8\xFFFF\x1\x1\x5\xFFFF\x1\x2",
				"\x1\x3\x1\xFFFF\x1\x1\x1\x3\x8\xFFFF\x1\x1\x5\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA1_eot = DFA.UnpackEncodedString(DFA1_eotS);
		private static readonly short[] DFA1_eof = DFA.UnpackEncodedString(DFA1_eofS);
		private static readonly char[] DFA1_min = DFA.UnpackEncodedStringToUnsignedChars(DFA1_minS);
		private static readonly char[] DFA1_max = DFA.UnpackEncodedStringToUnsignedChars(DFA1_maxS);
		private static readonly short[] DFA1_accept = DFA.UnpackEncodedString(DFA1_acceptS);
		private static readonly short[] DFA1_special = DFA.UnpackEncodedString(DFA1_specialS);
		private static readonly short[][] DFA1_transition;

		static DFA1()
		{
			int numStates = DFA1_transitionS.Length;
			DFA1_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA1_transition[i] = DFA.UnpackEncodedString(DFA1_transitionS[i]);
			}
		}

		public DFA1( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 1;
			this.eot = DFA1_eot;
			this.eof = DFA1_eof;
			this.min = DFA1_min;
			this.max = DFA1_max;
			this.accept = DFA1_accept;
			this.special = DFA1_special;
			this.transition = DFA1_transition;
		}

		public override string Description { get { return "43:9: ( declBlock )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA4 : DFA
	{
		private const string DFA4_eotS =
			"\x4\xFFFF";
		private const string DFA4_eofS =
			"\x4\xFFFF";
		private const string DFA4_minS =
			"\x2\x8\x2\xFFFF";
		private const string DFA4_maxS =
			"\x2\x1C\x2\xFFFF";
		private const string DFA4_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA4_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA4_transitionS =
			{
				"\x1\x3\x1\xFFFF\x1\x1\x9\xFFFF\x1\x1\x7\xFFFF\x1\x2",
				"\x1\x3\x1\xFFFF\x1\x1\x9\xFFFF\x1\x1\x7\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA4_eot = DFA.UnpackEncodedString(DFA4_eotS);
		private static readonly short[] DFA4_eof = DFA.UnpackEncodedString(DFA4_eofS);
		private static readonly char[] DFA4_min = DFA.UnpackEncodedStringToUnsignedChars(DFA4_minS);
		private static readonly char[] DFA4_max = DFA.UnpackEncodedStringToUnsignedChars(DFA4_maxS);
		private static readonly short[] DFA4_accept = DFA.UnpackEncodedString(DFA4_acceptS);
		private static readonly short[] DFA4_special = DFA.UnpackEncodedString(DFA4_specialS);
		private static readonly short[][] DFA4_transition;

		static DFA4()
		{
			int numStates = DFA4_transitionS.Length;
			DFA4_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA4_transition[i] = DFA.UnpackEncodedString(DFA4_transitionS[i]);
			}
		}

		public DFA4( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 4;
			this.eot = DFA4_eot;
			this.eof = DFA4_eof;
			this.min = DFA4_min;
			this.max = DFA4_max;
			this.accept = DFA4_accept;
			this.special = DFA4_special;
			this.transition = DFA4_transition;
		}

		public override string Description { get { return "()+ loopback of 48:33: ( decl )+"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA23 : DFA
	{
		private const string DFA23_eotS =
			"\x4\xFFFF";
		private const string DFA23_eofS =
			"\x2\x2\x2\xFFFF";
		private const string DFA23_minS =
			"\x1\x8\x1\xA\x2\xFFFF";
		private const string DFA23_maxS =
			"\x2\x1B\x2\xFFFF";
		private const string DFA23_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA23_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA23_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x1\x1\x2\x8\xFFFF\x1\x1\x2\xFFFF\x1\x2\x3\xFFFF\x1"+
				"\x3",
				"\x1\x1\x9\xFFFF\x1\x1\x2\xFFFF\x1\x2\x3\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA23_eot = DFA.UnpackEncodedString(DFA23_eotS);
		private static readonly short[] DFA23_eof = DFA.UnpackEncodedString(DFA23_eofS);
		private static readonly char[] DFA23_min = DFA.UnpackEncodedStringToUnsignedChars(DFA23_minS);
		private static readonly char[] DFA23_max = DFA.UnpackEncodedStringToUnsignedChars(DFA23_maxS);
		private static readonly short[] DFA23_accept = DFA.UnpackEncodedString(DFA23_acceptS);
		private static readonly short[] DFA23_special = DFA.UnpackEncodedString(DFA23_specialS);
		private static readonly short[][] DFA23_transition;

		static DFA23()
		{
			int numStates = DFA23_transitionS.Length;
			DFA23_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA23_transition[i] = DFA.UnpackEncodedString(DFA23_transitionS[i]);
			}
		}

		public DFA23( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 23;
			this.eot = DFA23_eot;
			this.eof = DFA23_eof;
			this.min = DFA23_min;
			this.max = DFA23_max;
			this.accept = DFA23_accept;
			this.special = DFA23_special;
			this.transition = DFA23_transition;
		}

		public override string Description { get { return "()* loopback of 75:25: ( ( ignore )* '|' ( ignore )* a= andExpr -> ^( '|' $orExpr $a) )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA26 : DFA
	{
		private const string DFA26_eotS =
			"\x4\xFFFF";
		private const string DFA26_eofS =
			"\x2\x2\x2\xFFFF";
		private const string DFA26_minS =
			"\x1\x8\x1\xA\x2\xFFFF";
		private const string DFA26_maxS =
			"\x2\x1B\x2\xFFFF";
		private const string DFA26_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA26_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA26_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x1\x1\x2\x8\xFFFF\x1\x1\x1\x3\x1\xFFFF\x1\x2\x3\xFFFF"+
				"\x1\x2",
				"\x1\x1\x9\xFFFF\x1\x1\x1\x3\x1\xFFFF\x1\x2\x3\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA26_eot = DFA.UnpackEncodedString(DFA26_eotS);
		private static readonly short[] DFA26_eof = DFA.UnpackEncodedString(DFA26_eofS);
		private static readonly char[] DFA26_min = DFA.UnpackEncodedStringToUnsignedChars(DFA26_minS);
		private static readonly char[] DFA26_max = DFA.UnpackEncodedStringToUnsignedChars(DFA26_maxS);
		private static readonly short[] DFA26_accept = DFA.UnpackEncodedString(DFA26_acceptS);
		private static readonly short[] DFA26_special = DFA.UnpackEncodedString(DFA26_specialS);
		private static readonly short[][] DFA26_transition;

		static DFA26()
		{
			int numStates = DFA26_transitionS.Length;
			DFA26_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA26_transition[i] = DFA.UnpackEncodedString(DFA26_transitionS[i]);
			}
		}

		public DFA26( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 26;
			this.eot = DFA26_eot;
			this.eof = DFA26_eof;
			this.min = DFA26_min;
			this.max = DFA26_max;
			this.accept = DFA26_accept;
			this.special = DFA26_special;
			this.transition = DFA26_transition;
		}

		public override string Description { get { return "()* loopback of 79:19: ( ( ignore )* '&' ( ignore )* a= term -> ^( '&' $andExpr $a) )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declBlock_in_prog119 = new BitSet(new ulong[]{0x100D00UL});
		public static readonly BitSet _expr_in_prog122 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ignore_in_declBlock145 = new BitSet(new ulong[]{0x4100400UL});
		public static readonly BitSet _26_in_declBlock148 = new BitSet(new ulong[]{0x100500UL});
		public static readonly BitSet _ignore_in_declBlock150 = new BitSet(new ulong[]{0x100500UL});
		public static readonly BitSet _decl_in_declBlock153 = new BitSet(new ulong[]{0x10100500UL});
		public static readonly BitSet _ignore_in_declBlock156 = new BitSet(new ulong[]{0x10100400UL});
		public static readonly BitSet _28_in_declBlock159 = new BitSet(new ulong[]{0x100402UL});
		public static readonly BitSet _ignore_in_declBlock161 = new BitSet(new ulong[]{0x100402UL});
		public static readonly BitSet _ignore_in_decl181 = new BitSet(new ulong[]{0x100500UL});
		public static readonly BitSet _type_in_decl184 = new BitSet(new ulong[]{0x100500UL});
		public static readonly BitSet _ignore_in_decl186 = new BitSet(new ulong[]{0x100500UL});
		public static readonly BitSet _name_in_decl189 = new BitSet(new ulong[]{0x500400UL});
		public static readonly BitSet _ignore_in_decl191 = new BitSet(new ulong[]{0x500400UL});
		public static readonly BitSet _22_in_decl194 = new BitSet(new ulong[]{0x900780UL});
		public static readonly BitSet _ignore_in_decl196 = new BitSet(new ulong[]{0x900780UL});
		public static readonly BitSet _args_in_decl199 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _23_in_decl202 = new BitSet(new ulong[]{0x2100400UL});
		public static readonly BitSet _ignore_in_decl204 = new BitSet(new ulong[]{0x2100400UL});
		public static readonly BitSet _25_in_decl207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_type231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_name252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arg_in_args271 = new BitSet(new ulong[]{0x1100402UL});
		public static readonly BitSet _ignore_in_args273 = new BitSet(new ulong[]{0x1100402UL});
		public static readonly BitSet _24_in_args278 = new BitSet(new ulong[]{0x100780UL});
		public static readonly BitSet _ignore_in_args280 = new BitSet(new ulong[]{0x100780UL});
		public static readonly BitSet _arg_in_args283 = new BitSet(new ulong[]{0x1100402UL});
		public static readonly BitSet _ignore_in_args285 = new BitSet(new ulong[]{0x1100402UL});
		public static readonly BitSet _ID_in_arg308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_arg321 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_arg334 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ignore_in_expr354 = new BitSet(new ulong[]{0x100D00UL});
		public static readonly BitSet _orExpr_in_expr357 = new BitSet(new ulong[]{0x100D02UL});
		public static readonly BitSet _ignore_in_expr360 = new BitSet(new ulong[]{0x100402UL});
		public static readonly BitSet _andExpr_in_orExpr387 = new BitSet(new ulong[]{0x8100402UL});
		public static readonly BitSet _ignore_in_orExpr395 = new BitSet(new ulong[]{0x8100400UL});
		public static readonly BitSet _27_in_orExpr398 = new BitSet(new ulong[]{0x100D00UL});
		public static readonly BitSet _ignore_in_orExpr400 = new BitSet(new ulong[]{0x100D00UL});
		public static readonly BitSet _andExpr_in_orExpr405 = new BitSet(new ulong[]{0x8100402UL});
		public static readonly BitSet _term_in_andExpr432 = new BitSet(new ulong[]{0x300402UL});
		public static readonly BitSet _ignore_in_andExpr440 = new BitSet(new ulong[]{0x300400UL});
		public static readonly BitSet _21_in_andExpr443 = new BitSet(new ulong[]{0x100D00UL});
		public static readonly BitSet _ignore_in_andExpr445 = new BitSet(new ulong[]{0x100D00UL});
		public static readonly BitSet _term_in_andExpr450 = new BitSet(new ulong[]{0x300402UL});
		public static readonly BitSet _NOT_in_term476 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _ID_in_term478 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_term493 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom505 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _22_in_atom511 = new BitSet(new ulong[]{0x100D00UL});
		public static readonly BitSet _ignore_in_atom513 = new BitSet(new ulong[]{0x100D00UL});
		public static readonly BitSet _orExpr_in_atom516 = new BitSet(new ulong[]{0x900400UL});
		public static readonly BitSet _ignore_in_atom518 = new BitSet(new ulong[]{0x900400UL});
		public static readonly BitSet _23_in_atom521 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
